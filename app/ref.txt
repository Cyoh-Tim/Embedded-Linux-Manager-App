사전 작업
touch ipc.key                 # Why? : ftok 함수를 위함

compile 방법
gcc -o main_ipc main_ipc.c common_ipc.c
gcc -o led_manager_proc led_manager_proc.c led_manager.c common_ipc.c
gcc -o motor_manager_proc motor_manager_proc.c motor_manager.c common_ipc.c
gcc -o state_manager_proc state_manager_proc.c state_manager.c common_ipc.c
gcc -o power_manager_proc power_manager_proc.c power_manager.c common_ipc.c

bash
./main_ipc

초기 개발 구조
.
├── ipc.key                   # 키 생성을 위한 빈 파일 (필수 사전 작업)
├── common_ipc.h              # 공통 정의 및 헬퍼 함수 선언
├── common_ipc.c              # 헬퍼 함수 구현
├── led_manager.h             # LED 드라이버 선언
├── led_manager.c             # LED 드라이버 구현
├── led_manager_proc.c        # LED 프로세스 엔트리 포인트
├── motor_manager.h           # 모터 드라이버 선언
├── motor_manager.c           # 모터 드라이버 구현
├── motor_manager_proc.c      # 모터 프로세스 엔트리 포인트
├── power_manager.h           # 전원 관리 드라이버 선언 (간단)
├── power_manager.c           # 전원 관리 드라이버 구현 (간단)
├── power_manager_proc.c      # 전원 프로세스 엔트리 포인트
├── state_manager.h           # 상태 관리 드라이버 선언 (간단)
├── state_manager.c           # 상태 관리 드라이버 구현 (간단)
├── state_manager_proc.c      # 상태 프로세스 엔트리 포인트 (총괄 담당)
└── main_ipc.c                # 메인 애플리케이션 (부팅하고 이 프로세스를 실행한다는 가정)

위 폴더의 목적
Linux Embedded Application 코딩 방식을 구현.
실제 제품이라는 가정하에 작성하였으나 살짝 벗어나 있을 수도 있음.
계속 수정을 통해 구조를 좀 더 편하고 해석하기 쉽도록 혹은 트렌드에 맞는 코딩을 구현 예정
application 초기 구현 시 이 코드를 활용하여 빠른 개발 및 참고를 위해 구현하는 것이 최종 목적

구현 방법
main ipc에서 모든 매니저 proc을 fork.
*_manager_proc 파일은 message queue 방식으로 메세지를 주고 받으며 필요한 동작을 manager.c의 함수를 호출하는 식으로 구현하면 됨.

참고하면 좋은 것
메세지를 구현할 때 payload로 char *형식을 받아서 어떤 내용인지 판단하여 동작하게끔 했지만
극한적으로 메모리를 아끼고자 할 때 아예 payload를 없애고 command 하나로만 메세지를 구현하는 방법도 있다.
예시로 CMD_MOTOR_START 이런 식으로 이름을 만들어 구현하게된다.
물론 UART log로 분석할 경우엔 "이 숫자가 뭐였더라.." 하면서 개발할 때 답답한 점도 분명 존재하겠다.
당연히 추천은 현재 구현된 방식이긴하다.

기본 지식
컴파일 명령어 및 프로세스의 개념이 어려운 경우 참고
gcc -o xx # 파일명을 xx로한 실행 파일 생성 (이 파일을 실행하면 프로세스가 된다.)
          # 그렇다면 뒤에 붙은 파일 이름들은 이 프로세스에 넣을 c파일인 것이다.
          # main 함수가 진입점이니 main 함수는 파일들에 단 하나만 있어야한다.